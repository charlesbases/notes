# 设计模式

---

## 1. 简单工厂模式

---

## 2. 策略模式

```
定义了算法家族，分别封装起来，让他们之间可以相互替换，此模式让算法的替换，不会影响到使用算法的用户
```

```
策略模式是一种定义一系列算法的方法，从概念上看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合
```

---

## 3. 单一职责原则

```
就一个类而言，应该仅有一个引起它变化的原因
```

---

## 4. 开放-封闭原则

```
对于软件实体（类、模块、函数等）应该可以扩展，但是不可修改
```

---

## 5. 依赖倒转原则

```
A. 高层模块不应该依赖底层模块。俩个都应该依赖抽象 
B. 抽象不应该依赖细节。细节应该依赖抽象
```

### 5.1. 里氏代换原则

```
子类型必须能够替换掉它们的父类型
```

```
一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化
```

---

## 6. 装饰模式

```
动态的给一个对象添加一些额外的职责
```

---

## 7. 代理模式

---

## 8. 工厂方法模式

---

## 9. 原型模式

---

## 10. 模板方法模式

---

## 11. 迪米特原则

```
迪米特法则其根本思想，是强调了类之间的松耦合
```

```
如果俩个类不必彼此直接通信，那么这俩个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用
```

---

## 12. 外观模式

---

## 13. 建造者模式

---

## 14. 观察者模式

---

## 15. 抽象工厂模式

---

## 16. 状态模式

---

## 17. 适配器模式

---

## 18. 备忘录模式

---

## 19. 组合模式

---

## 20. 迭代器模式

---

## 21. 单例模式

---

## 22. 桥接模式

---

## 23. 命令模式

---

### 23.1. 敏捷开发原则

```
不要为代码添加基于猜测的，实际不需要的功能
```

---

## 24. 职责链模式

---

## 25. 中介者模式

---

## 26. 享元模式

---

## 27. 解释器模式

---

## 28. 访问者模式

