## 设计原则

```shell
# 1. 减少代码耦合，对于高度耦合的代码，当希望复用其中的一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。移动一点代码，就要牵连到很多其他相关的代码。所以，高度耦合的代码会影响到代码的复用性，要尽量减少代码耦合。

# 2. 满足单一职责原则，如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码就会比较多，进而增加了代码的耦合。根据上一点，也就会影响到代码的复用性。相反，越细粒度的代码，代码的通用性会越好，越容易被复用。

# 3. 模块化，模块不单单指一组类构成的模块，还可以理解为单个类、函数。要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统。

# 4. 业务与非业务逻辑分离，越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。所以，为了复用跟业务无关的代码，需要将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等。

# 5. 通用代码下沉，从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，通常只允许上层代码调用下层代码及同层代码之间的调用，杜绝下层代码调用上层代码。所以，通用的代码我们尽量下沉到更下层。

# 6. 继承、多态、抽象、封装，利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，可以动态地替换一段代码的部分逻辑，让这段代码可复用。除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的话，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用。

# 7. 应用模板等设计模式，一些设计模式，也能提高代码的复用性。比如，模板模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模板代码可复用。

# 除此之外还有一些跟编程语言相关的特性，也能提高代码的复用性，比如泛型编程等。实际上，除了上面讲到的这些方法之外，复用意识也非常重要。在写代码的时候要多去思考一下，这个部分代码是否可以抽取出来，作为一个独立的模块、类或者函数供多处使用。在设计每个模块、类、函数的时候，要像设计一个外部 API 那样，去思考它的复用性。
```



### 1. 单一职责原则

### 2. 里氏替换原则

- 子类必须完全实现父类的方法
- 子类可以有自己的个性
- 覆盖或实现父类的方法时输入参数可以被放大
- 覆写或实现父类的方法时输出结果可以被缩小

### 3. 依赖倒置原则

- 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的;
- 接口或抽象类不依赖于实现类;
- 实现类依赖接口或抽象类.

```shell
# 接口或抽象类中不应该出现实现类; 实现类中不应该出现其他实现类.
```



### 4. 接口隔离原则

- 客户端不应该依赖它不需要的接口;
- 类间的依赖关系应该建立在最小的接口上.

```shell
# 接口的设计粒度越小，系统越灵活，这是不争的事实。但是，灵活的同时也带来了结构的复杂化，开发难度增加，可维护性降低.
```



### 5. 迪米特法则

```shell
# 类解耦
```



### 6. 开闭原则

```shell
# 软件实体应该对扩展开放，对修改关闭
```



### KISS 原则

`Keep It Simple and Stupid` `尽量保持简单`

```shell
# 1. 不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。如果想用，培训一下大家

# 2. 不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高。

# 3. 不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。
```



### YAGNI 原则

`You Ain’t Gonna Need It` `不要做过度设计`

```shell
# 比如，系统暂时只用 Redis 存储配置信息，以后可能会用到 ZooKeeper。根据 YAGNI 原则，在未用到 ZooKeeper 之前，我们没必要提前编写这部分代码。当然，这并不是说我们就不需要考虑代码的扩展性。我们还是要预留好扩展点，等到需要的时候，再去实现 ZooKeeper 存储配置信息这部分代码
```



### DRY 原则

`Don’t Repeat Yourself` `不要写重复代码

```shell
# 实现逻辑重复，但功能语义不重复的代码，并不违反 DRY 原则，可以通过更细粒度的SRP改造来去除重复代码。(eg: 校验用户的用户名和密码)

# 实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY 原则。(eg: 使用不同的方式判断 IP 地址是否有效)

# 代码执行重复也算是违反 DRY 原则
```



---

## 设计模式

---

## 模式总结

### 创建类模式

#### 工厂方法 VS 建造者模式

```shell
# 工厂方法模式注重的是整体对象的创建方法
# 建造者模式注重的是部件构建的过程, 旨在通过一步一步地精确构造创建出一个复杂的对象
```



#### 抽象工厂 VS 建造者模式

```shell

```



### 结构类模式

#### 代理模式 VS 装饰模式

```shell
# 代理模式着重对代理过程的控制
# 装饰模式则是对类的功能进行加强或减弱，它着重类的功能变化，
```



#### 装饰模式 VS 适配器模式

### 行为类模式

#### 命令模式 VS 策略模式

#### 策略模式 VS 状态模式

#### 观察者模式 VS 责任链模式

### 包装类模式

#### 代理模式

#### 装饰模式

#### 桥梁模式

#### 适配器模式